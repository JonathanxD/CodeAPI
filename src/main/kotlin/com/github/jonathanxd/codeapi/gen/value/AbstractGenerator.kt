/*
 *      CodeAPI - Framework to generate Java code and Bytecode code. <https://github.com/JonathanxD/CodeAPI>
 *
 *         The MIT License (MIT)
 *
 *      Copyright (c) 2017 TheRealBuggy/JonathanxD (https://github.com/JonathanxD/ & https://github.com/TheRealBuggy/) <jonathan.scripter@programmer.net>
 *      Copyright (c) contributors
 *
 *
 *      Permission is hereby granted, free of charge, to any person obtaining a copy
 *      of this software and associated documentation files (the "Software"), to deal
 *      in the Software without restriction, including without limitation the rights
 *      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *      copies of the Software, and to permit persons to whom the Software is
 *      furnished to do so, subject to the following conditions:
 *
 *      The above copyright notice and this permission notice shall be included in
 *      all copies or substantial portions of the Software.
 *
 *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *      THE SOFTWARE.
 */
package com.github.jonathanxd.codeapi.gen.value

import com.github.jonathanxd.codeapi.CodePart
import com.github.jonathanxd.codeapi.CodeSource
import com.github.jonathanxd.codeapi.annotation.Default
import com.github.jonathanxd.codeapi.annotation.GenerateTo
import com.github.jonathanxd.codeapi.common.Data
import com.github.jonathanxd.codeapi.gen.Appender
import com.github.jonathanxd.codeapi.gen.CodeGenerator
import com.github.jonathanxd.codeapi.util.ClassUtil
import com.github.jonathanxd.codeapi.util.gento.GenToUtil
import com.github.jonathanxd.iutils.container.primitivecontainers.IntContainer
import java.util.*
import java.util.logging.Logger

/**
 * Generator of [T] from a [CodeSource] (source of [CodePart]).
 *
 * @param <T> Output type
 * @param <C> Generator type
 */
abstract class AbstractGenerator<T, C : AbstractGenerator<T, C>> : CodeGenerator<T> {

    @Synchronized override fun gen(source: CodeSource, data: Data, additional: Any?): T {
        val appender = createAppender()

        val instance = this

        val index = IntContainer(-1)

        val codeSourceData = CodeSourceData(source, index)


        for (i in 0..source.size - 1) {
            val part = source[i]

            index.set(i)

            val call = generateTo(part.javaClass /*as Class<? extends CodePart>*/, part, null, codeSourceData, data)

            if (!call.isEmpty()) {
                for (value in call) {
                    AbstractGenerator.helpApply(value, part, instance, appender, codeSourceData, data)
                }
            } else {
                throw IllegalStateException("Cannot find generator for '" + part.javaClass.canonicalName + "'")
            }
        }

        return appender.get()
    }

    /**
     * Create a appender.
     *
     * @return Appender
     */
    abstract fun createAppender(): Appender<T>

    /**
     * Generate [Value]s from a [CodePart].
     *
     * @param generatorTargetClass Generator target class (this parameter is used to determine which [ValueGenerator] to use to process `target`).
     * @param target               Target part to generate the [Value]s
     * @param parents              Parent [ValueGenerator]s
     * @param codeSourceData       Data of the source.
     * @param processingData       Data of the processing environment.
     * @return Values generated by generators.
     */
    fun generateTo(generatorTargetClass: Class<*>, target: Any, parents: Parent<ValueGenerator<*, T, C>>?, codeSourceData: CodeSourceData, processingData: Data): List<Value<*, T, C>> {
        val registry = registry

        val entryComparator = EntryComparator(generatorTargetClass)

        val targetClass: Class<*>

        val generateTo = generatorTargetClass.getDeclaredAnnotation(GenerateTo::class.java)

        if (generateTo != null && generateTo.value != Default::class.java) {
            targetClass = generateTo.value.java
        } else {
            targetClass = generatorTargetClass
        }

        var filterEntry: Map.Entry<Class<*>, ValueGenerator<*, T, C>>? = registry.entries.filter { entry -> entry.key == targetClass }.sortedWith(entryComparator).firstOrNull()

        if (filterEntry == null) {
            for (aClass in ClassUtil.getAllSubclasses(generatorTargetClass)) {
                if (registry.containsKey(aClass)) {
                    filterEntry = AbstractMap.SimpleEntry<Class<*>, ValueGenerator<*, T, C>>(aClass, registry[aClass])
                    break
                }
            }
        }

        var get: ValueGenerator<*, T, C>? = try {
            GenToUtil.get(targetClass, this.registry)
        } catch (ignore: Throwable) {
            null
        }

        if (get == null)
            get = if (filterEntry != null) filterEntry.value else null

        if (get == null) {
            if (generatorTargetClass.isSynthetic || generatorTargetClass.isAnonymousClass || generatorTargetClass.isLocalClass) {
                val i: Class<*>
                if (generatorTargetClass.interfaces.isEmpty()) {
                    i = generatorTargetClass.superclass
                } else {
                    i = generatorTargetClass.interfaces[0]
                }

                get = Objects.requireNonNull<ValueGenerator<*, T, C>>(registry[i], "Cannot get processor of class: '" + i.canonicalName + "' (Local/Synthetic/Anonymous class): '" + generatorTargetClass + "'")
            }
        }

        if (get != null) {

            if (filterEntry != null && filterEntry.key != targetClass)
                logger.warning("Processor of '" + targetClass.canonicalName + "' isn't registered, using generic generator: '" + filterEntry.key + "'!")
            try {
                return ArrayList(AbstractGenerator.help(get, target, this, Parent.create<ValueGenerator<*, T, C>>(get, target, parents), codeSourceData, processingData))
            } catch (t: Throwable) {
                throw RuntimeException("Cannot parse! See parents: '$parents'. ", t)
            }

        }

        throw IllegalStateException("Cannot find generator for '" + generatorTargetClass.canonicalName + "' while processing '" + target.javaClass.canonicalName + "'. Parents = " + parents)
    }

    /**
     * Gets the registry of the Generators

     * @return Registry of the generators.
     */
    protected abstract val registry: Map<Class<*>, ValueGenerator<*, T, C>>

    private inner class EntryComparator internal constructor(private val currentClass: Class<*>) : Comparator<Map.Entry<Class<*>, ValueGenerator<*, T, C>>> {
        private val allSubClasses = ArrayList<Class<*>>()

        init {
            allSubClasses.addAll(ClassUtil.getAllSubclasses(currentClass))
        }

        override fun compare(o1: Map.Entry<Class<*>, ValueGenerator<*, T, C>>, o2: Map.Entry<Class<*>, ValueGenerator<*, T, C>>): Int {
            for (allSubClass in allSubClasses) {
                if (allSubClass == o1.key) {
                    return 1
                }
                if (allSubClass == o2.key) {
                    return -1
                }
            }

            return if (o1.key == currentClass) 1 else if (o2.key == currentClass) -1 else 0
        }
    }

    companion object {

        /**
         * Logger
         */
        private val logger = Logger.getLogger("AbstractGenerator")

        /**
         * Help generics.
         *
         * Cast types and call [Value.apply].
         *
         * @param value          Value.
         * @param target         Target Code Part.
         * @param instance       Instance of [AbstractGenerator].
         * @param appender       [T] appender.
         * @param codeSourceData Data of the source.
         * @param processingData Data of the processing environment.
         * @param T              Type of `target` part.
         * @param C              Type of [AbstractGenerator].
         */
        @Suppress("UNCHECKED_CAST")
        fun <T, C> helpApply(value: Value<*, T, C>, target: CodePart, instance: Any, appender: Appender<T>, codeSourceData: CodeSourceData, processingData: Data) {
            value.apply(target, instance as C, appender, codeSourceData, processingData)
        }

        /**
         * Help generics.
         *
         * Cast types and call [ValueGenerator.gen].
         *
         * @param generator      Generator
         * @param target         Target code part
         * @param instance       Instance of [AbstractGenerator]
         * @param parents        Parent generators (bug tracing)
         * @param codeSourceData Data of the source.
         * @param processingData Data of the processing environment.
         * @param E              Type of `target` part.
         * @param T              [ValueGenerator] output type.
         * @param C              Type of [AbstractGenerator].
         */
        @Suppress("UNCHECKED_CAST")
        private fun <E, T, C> help(generator: ValueGenerator<E, T, C>, target: Any, instance: Any, parents: Parent<ValueGenerator<*, T, C>>, codeSourceData: CodeSourceData, processingData: Data): List<Value<*, T, C>> {
            return generator.gen(target as E, instance as C, parents, codeSourceData, processingData)
        }
    }
}
